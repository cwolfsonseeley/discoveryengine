<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">



<title></title>


<style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet"
      href="developer-notes_files/highlight/default.css"
      type="text/css" />
<script src="developer-notes_files/highlight/highlight.js"></script>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>




<link rel="stylesheet" href="stylesheets\github-light.css" type="text/css" />

</head>

<body>







<div class="wrapper">
<header>
<a href="index.html">
<h1>
Discoveryengine
</h1>
</a>
<p>
</p>
<p class="view">
<a href="https://github.com/tarakc02/discoveryengine">View the Project on GitHub <small>tarakc02/discoveryengine</small></a>
</p>
<ul>
<li>
<a href="examples.html">Introductory <strong>Examples</strong></a>
</li>
<li>
<a href="developer-notes.html">Notes for <strong>Developers</strong></a>
</li>
<li>
<a href="https://github.com/tarakc02/discoveryengine">View On <strong>GitHub</strong></a>
</li>
</ul>
</header>
<section>
<h2 id="building-a-new-discoveryengine-widget">Building a new discoveryengine widget</h2>
<p>Today I’ll be adding the <code>majored_in</code> widget to the discoveryengine. The steps that we’ll go through are the same steps you’d take any time you were adding a new widget.</p>
<h3 id="getting-started">Getting started</h3>
<p>I’ve already cloned the discoveryengine repository and am working in a local directory. I start by loading existing code (if you’re using RStudio, you can do this with Ctrl/Cmd + shift + l).</p>
<pre class="r"><code>devtools::load_all(&quot;.&quot;)</code></pre>
<pre><code>## Loading discoveryengine</code></pre>
<p>It’s helpful as a first step to write a failing test. Tests serve as documentation for your widget, by specifying clearly the tables and fields that will be used by the widget. So I create a new file <code>tests/testthat/test-majored-in.R</code>:</p>
<pre class="r"><code>context(&quot;majored_in specifications&quot;)
source(&quot;helpers.R&quot;)
library(magrittr)

test_that(&quot;majored_in meets specifications on standard input&quot;, {
    test &lt;- majored_in(540, 651, 084)
    test %&gt;% uses_table(&quot;d_bio_degrees_mv&quot;)
    test %&gt;% id_of_type(&quot;entity_id&quot;)
    test %&gt;% id_field_is(&quot;entity_id&quot;)

    test %&gt;%
        has_filters(local_ind = &quot;Y&quot;,
                    major_code1 = c(&quot;540&quot;, &quot;651&quot;, &quot;084&quot;))

    test %&gt;% has_clause_count(2)

})

test_that(&quot;majored_in meets specifications on no input&quot;, {
    majored_in() %&gt;%
        has_clause_count(1)
    majored_in() %&gt;% uses_table(&quot;d_bio_degrees_mv&quot;)
    majored_in() %&gt;% has_filters(local_ind = &quot;Y&quot;)
})</code></pre>
<p>Notice the tests make clear that, for the purposes of this widget, majors are determined by looking at the <code>major_code1</code> field in the <code>d_bio_degrees_mv</code> table. Also note that the test cases include input that I know (from experience) might cause problems, for instance a major code starting with a “0”.</p>
<p>In RStudio, you can run tests using Ctrl/Cmd + shift + t. After adding the new tests for the <code>majored_in</code> widget, I see some failures in the test output.</p>
<h3 id="constructing-the-widget">Constructing the widget</h3>
<p>Now it’s time to build a widget that will pass those tests. Since the discoveryengine uses <a href="http://adv-r.had.co.nz/Computing-on-the-language.html">non-standard evaluation</a>, we follow the guidelines set out in Hadley Wickham’s <a href="http://adv-r.had.co.nz/">Advanced R book</a>, creating a standard-evaluation escape hatch:</p>
<pre class="r"><code># prep dots will turn dots into an object
majored_in &lt;- function(...) majored_in_(prep_dots(...))

# escape hatch has the same name, but with an underscore
majored_in_ &lt;- function(majors) {
    # here&#39;s where the code will go
}</code></pre>
<p>To fill in the body of the <code>majored_in_</code> function, I’ll use the helper function <code>widget_builder</code>. <code>widget_builder</code> takes some basic specifications for a widget, and builds out all of the functionality that we’ve come to know and love. At a minimum, <code>widget_builder</code> requires you to specify the table, id field, and id type for your widget:</p>
<pre class="r"><code>majored_in_ &lt;- function(majors) {
    widget_builder(
        table = &quot;d_bio_degrees_mv&quot;,
        id_field = &quot;entity_id&quot;,
        id_type = &quot;entity_id&quot;
    )
}</code></pre>
<p>The <code>table</code> is the name of the data warehouse table you need to query for this widget. The <code>id_field</code> is the name of the field in that table that you’ll return. The <code>id_type</code> is a standardized name for the IDs you’re pulling.</p>
<h3 id="widget-id-types">Widget ID Types</h3>
<p>The <code>id_type</code> determines which widgets your new widget will be able to combine with, since only widgets with the same <code>id_type</code> can be combined. If you had a widget with an ID type of <code>proposal_id</code> called <code>is_gp_proposal</code> and another widget of with an ID type of <code>entity_id</code> called <code>is_gp_prospect</code>, trying to combine them would look something like this:</p>
<pre class="r"><code>is_gp_proposal %and% is_gp_prospect</code></pre>
<p>What would that even mean? In a day-to-day conversation, someone asking you for a list of things that are at the same time gift planning proposals and gift planning prospects, you would be rightfully confused since one of those predicates refers to an abstract solicitation plan and the other refers to a human being. Accordingly, the formulation above would result in an error.</p>
<h3 id="adding-a-parameter">Adding a parameter</h3>
<p>At this point, we have a functioning widget called <code>majored_in</code>. Run a test with Ctrl/Cmd + Shift + t. We’re still failing, but the failure message is different! Let’s see what we have:</p>
<pre class="r"><code>test &lt;- majored_in(540, 651, 084)
test</code></pre>
<pre><code>## LISTBUILDER DEFINITION (type: entity_id)
## .   source: d_bio_degrees_mv.entity_id (entity_id)
## .   logic:</code></pre>
<pre class="r"><code>cat(to_sql(test))</code></pre>
<pre><code>## select distinct entity_id from (
## select d_bio_degrees_mv.entity_id as entity_id
## from CDW.d_bio_degrees_mv
## )</code></pre>
<p>So we’re looking at the correct CDW table, and pulling the correct field, but we haven’t implemented any of the logic to look for the requested majors. We’ll start by adding a <em>parameter</em>, which is the primary way to interact with a widget. In this case, our parameter needs to look at the <code>major_code1</code> field, as specified in our unit tests. Since the parameter is a string, we’ll use the <code>string_param</code> function. In order to see how the <code>string_param</code> function works, we’ll see what it does to some sample input. Here I use <code>prep_dots</code> to present the parameter in the same way that it will be presented to the <code>majored_in_</code> function.</p>
<pre class="r"><code>majors &lt;- prep_dots(540, 651, 084)
string_param(&quot;major_code1&quot;, majors)</code></pre>
<pre><code>## [[1]]
## major_code1 %in% c(&quot;540&quot;, &quot;651&quot;, &quot;84&quot;)</code></pre>
<p>Hmmn, well that looks like a good start, but notice how the code with a leading zero got mangled. Codes that should be strings are interpreted as integers by R as soon as they are entered. For example:</p>
<pre class="r"><code>001</code></pre>
<pre><code>## [1] 1</code></pre>
<p>This kind of situation doesn’t come up too often, as most codes in CADS use letters and not numbers. But in this case, we need to do a little extra work to make sure our major codes all have the same width (3 characters), with leading zeroes if necessary. Fortunately, <code>string_param</code> has a <code>width</code> argument for just such an occasion:</p>
<pre class="r"><code>string_param(&quot;major_code1&quot;, majors, width = 3)</code></pre>
<pre><code>## [[1]]
## major_code1 %in% c(&quot;540&quot;, &quot;651&quot;, &quot;084&quot;)</code></pre>
<p>Alright, that looks good. Looking back at the unit test we started with, the only remaining logic that needs to be implemented is the part that looks at the <code>local_ind</code> field, which specifies that the degree in question is a UC Berkeley degree.</p>
<h3 id="switches">Switches</h3>
<p>While parameters are the major way to interact with a widget, we can also have switches to add some additional logic. Switches can be controlled by the user, but don’t have to be. If they are</p>
</section>
<footer>
<small>theme by <span class="citation">@orderedlist</span></small>
</footer>
</div>
<script src="javascripts/scale.fix.js"></script>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
