<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">



<title></title>


<style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet"
      href="developer-notes_files/highlight/default.css"
      type="text/css" />
<script src="developer-notes_files/highlight/highlight.js"></script>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>




<link rel="stylesheet" href="stylesheets\github-light.css" type="text/css" />

</head>

<body>







<div class="wrapper">
<header>
<a href="index.html">
<h1>
Discoveryengine
</h1>
</a>
<p>
</p>
<p class="view">
<a href="https://github.com/tarakc02/discoveryengine">View the Project on GitHub <small>tarakc02/discoveryengine</small></a>
</p>
<ul>
<li>
<a href="examples.html">Introductory <strong>Examples</strong></a>
</li>
<li>
<a href="developer-notes.html">Notes for <strong>Developers</strong></a>
</li>
<li>
<a href="https://github.com/tarakc02/discoveryengine">View On <strong>GitHub</strong></a>
</li>
</ul>
</header>
<section>
<h2 id="understanding-how-the-discoveryengine-works">Understanding how the discoveryengine works</h2>
<p>The <code>discoveryengine</code> is based on a simple, but flexible, idea: prospecting is carried out by creating and combining lists of IDs in various ways, and lists of IDs are defined by a predicate, such as “has a degree from the college of chemistry” or “has an interest in architecture.” The <code>discoveryengine</code> defines a set of widgets and converters. Widgets are functions that create predicates. For example, the <code>has_degree_from</code> widget creates predicates such as <code>has_degree_from(business)</code> or <code>has_degree_from(natural_resources)</code>. Converters add additional power – they are like second-order widgets in that they define predicates in terms of other predicates – for example <code>child_of(has_capacity(1:9))</code> This document looks at how widgets and converters are built.</p>
<h3 id="widgets">Widgets</h3>
<p>Widgets are built, appropriately, with the <code>widget_builder</code> function. <code>widget_builder</code> takes the following arguments, and outputs a widget:</p>
<ul>
<li><code>table</code></li>
<li><code>id_field</code></li>
<li><code>id_type</code></li>
<li><code>parameter</code> (optional)</li>
<li><code>aggregate_parameter</code> (optional)</li>
<li><code>switches</code> (optional)</li>
<li><code>aggregate_switches</code> (optional)</li>
</ul>
<h4 id="table-id_field-and-id_type">table, id_field, and id_type</h4>
<p>These three fields describe the kind of ID that the widget will return. <code>table</code> is the name of the CDW table the ID comes from, <code>id_field</code> is the name of the id column in that table, and <code>id_type</code> describes what kind of ID it is (entity_id, allocation_id, etc). As an example, the giving widgets have <code>table = f_transaction_detail_mv</code>, <code>id_field = donor_entity_id_nbr</code>, and <code>id_type = entity_id</code>. The <code>id_type</code> constrains how a widget may be combined with other widgets. For instance, if <code>predicate_a</code> has an <code>id_type</code> of <code>entity_id</code> while <code>predicate_b</code> has an <code>id_type</code> of <code>allocation_id</code>, then <code>predicate_a %or% predicate_b</code> would result in an error.</p>
<h4 id="parameter-aggregate_parameter">parameter, aggregate_parameter</h4>
<p>A widget can have up to one parameter, and the parameter serves as the primary way a user can control a widget. In the usage <code>has_degree_from(business)</code> the parameter is <code>business</code>.</p>
<p>There are helper functions to create parameters. Currently, the only two such functions are <code>string_param</code> and <code>integer_param</code>, and the only two types of parameters that have been defined are string and integer. In the future, we may add additional parameter types, such as <code>zipcode_param</code> (currently we use <code>string_param</code> to handle zip codes, at the expense of sometimes screwing up zipcodes that begin with a ‘0’). <code>string_param</code> and <code>integer_param</code> both take as arguments the name of a field in the CDW, a list of unevaluated arguments, and (optionally) a default. This will make more sense with an example, so let’s take a look at the <code>gave_to_area</code> widget:</p>
<pre class="r"><code>library(discoveryengine)
print(gave_to_area)</code></pre>
<pre><code>## function (..., atleast = 0.01, from = NULL, to = NULL) 
## {
##     aogs &lt;- prep_dots(...)
##     gave_to_area_(aogs, atleast = atleast, from = from, to = to)
## }
## &lt;environment: namespace:discoveryengine&gt;</code></pre>
<p>All of the widgets in the <code>discoveryengine</code> support non-standard evaluation, and, following the recommendation from Hadley Wickham in his <a href="http://adv-r.had.co.nz/Computing-on-the-language.html#calling-from-another-function">Advanced R book</a>, have a standard evaluation “escape hatch” found by adding an underscore to the widet name.</p>
<pre class="r"><code>print(gave_to_area_)</code></pre>
<pre><code>## function (aogs, atleast = 0.01, from = NULL, to = NULL) 
## {
##     widget_builder(table = &quot;f_transaction_detail_mv&quot;, id_field = &quot;donor_entity_id_nbr&quot;, 
##         id_type = &quot;entity_id&quot;, parameter = string_param(&quot;alloc_school_code&quot;, 
##             aogs), switches = list(daterange(&quot;giving_record_dt&quot;, 
##             from, to), string_switch(&quot;pledged_basis_flg&quot;, &quot;Y&quot;)), 
##         aggregate_switches = sum_switch(&quot;benefit_aog_credited_amt&quot;, 
##             atleast))
## }
## &lt;environment: namespace:discoveryengine&gt;</code></pre>
<p>I’ll look at the switches in the following section, but note here the argument <code>parameter = string_param(&quot;alloc_school_code&quot;, aogs)</code>. <code>f_transaction_detail_mv.alloc_school_code</code> is the name of the field that will be used when filtering for transactions to a given area. <code>aogs</code> is the list of unevaluated expressions the user has entered, that may contain expressions such as <code>business</code> or <code>SHSB</code>. <code>string_param</code> will resolve syonyms such as <code>business</code> into area of giving codes, and will produce an expression whose meaning is: <code>alloc_school_code %in% aogs</code>.</p>
<p>An <code>aggregate_parameter</code> is a parameter that can only be applied after aggregation. No widgets currently use an <code>aggregate_parameter</code>, but in the next section we’ll look at an exmaple of an aggregate switch.</p>
<h4 id="switches-aggregate_switches">switches, aggregate_switches</h4>
<p>While the <code>parameter</code> is the primary way for the user to control a widget, there are often some secondary options, or switches, that can also be used. These are generally not directly related to codes from the TMS code table, but rather secondary options. For instance, <code>in_unit_portfolio</code> takes as a parameter the office code, such as <code>BU</code> (or equivalent synonym, such as <code>business</code>), as well as a switch <code>include_inactive</code>, which is either <code>TRUE</code> or <code>FALSE</code> depending on whether inactive proposals should be considered. Let’s look again at the <code>gave_to_area</code> example:</p>
<pre class="r"><code>print(gave_to_area_)</code></pre>
<pre><code>## function (aogs, atleast = 0.01, from = NULL, to = NULL) 
## {
##     widget_builder(table = &quot;f_transaction_detail_mv&quot;, id_field = &quot;donor_entity_id_nbr&quot;, 
##         id_type = &quot;entity_id&quot;, parameter = string_param(&quot;alloc_school_code&quot;, 
##             aogs), switches = list(daterange(&quot;giving_record_dt&quot;, 
##             from, to), string_switch(&quot;pledged_basis_flg&quot;, &quot;Y&quot;)), 
##         aggregate_switches = sum_switch(&quot;benefit_aog_credited_amt&quot;, 
##             atleast))
## }
## &lt;environment: namespace:discoveryengine&gt;</code></pre>
<p>Here we see the use of the helper function <code>daterange</code>, which takes a begin and end date and produces a daterange constraint. Significantly, <code>daterange</code> will accept <code>NULL</code> values for either or both of the date arguments, and will still behave as expected. Dates are entered as regular integers of the form YYYYMMDD (so June 6, 2016 would be 20160606).</p>
<p>We also see the <code>string_switch</code> function, which operates just like the <code>string_param</code> function above, except that it will not go through a synonym table or other validation. Finally, we see an aggregate switch, using the helper <code>sum_switch</code>. <code>sum_switch(&quot;benefit_aog_credited_amt&quot;, atleast)</code> says that the sum of <code>benefit_aog_credited_amt</code> should be greater than or equal to the value <code>atleast</code>. In all, then:</p>
<pre class="r"><code>gave_to_area(art_museum, cal_performances, 
             atleast = 5000, 
             from = 20140701, to = 20150630)</code></pre>
will find anyone who gave a total of $5,000 or more combined to the Berkeley Art Museum and/or Cal Performances between July 1, 2014 and June 30, 2015.
</section>
<footer>
<small>theme by <span class="citation">@orderedlist</span></small>
</footer>
</div>
<script src="javascripts/scale.fix.js"></script>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
